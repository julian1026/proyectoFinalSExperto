# -*- coding: utf-8 -*-
"""Parcial.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12LiVPdzil-nqjarNO_-3H9w4l5DjkCEh
"""

from google.colab import files #subir los archivos 
uploaded = files.upload()      #linea que permite subir el archivo .zip

!pwd  #linea que permite ver el directorio donde me encuentro dentro de google colab

import zipfile # para descomprimir el archivo
import io  # para tener acceso a los archivos
data = zipfile.ZipFile(io.BytesIO(uploaded['animales.zip']), 'r')
data.extractall() # extraer los datos del archivo

import cv2 #se importa la libreria para reconocimeinto de imagenes
import numpy as np #para los arreglos
import os #para utilizar los directorios
import matplotlib.pyplot as plt 
 
pandas_folder_path="/content/tigres" #ruta de la carpeta 
tigres=[] #lista que almacena las imagenes
img_size=150 #tama単o de imagen
for img in os.listdir(pandas_folder_path): 
    img = cv2.imread(os.path.join(pandas_folder_path,img))#lee las imagenes
    img_resize= cv2.resize(img,(img_size,img_size))# reduccion de las imagenes al tama単o
    tigres.append(img_resize) #a la lista le almacena las imagenes reducidas

tigres = np.array(tigres)# la lista se convierte a un arreglo
print(tigres.shape)

import cv2
import numpy as np
import os
import matplotlib.pyplot as plt
 
pandas_folder_path="/content/pandas"
pandast=[]
img_size=150
for img in os.listdir(pandas_folder_path):
    img = cv2.imread(os.path.join(pandas_folder_path,img))
    img_resize= cv2.resize(img,(img_size,img_size))
    pandast.append(img_resize)

pandast = np.array(pandast)
print(pandast.shape)

imagenes= np.concatenate([tigres,pandast]) #se concatena las dos carpetas
print(len(imagenes))# imprime la longitud de las imagenes que contiene
Imagen = np.array(imagenes) #las convierte a un arreglo
print(Imagen.shape) #conjunto de datos que representa cada imagen(sin shape)

etiquetas_tigres = np.repeat(0,6) #se le da una etiqueta a las imagenes
print(len(etiquetas_tigres)) #longitud  o cantidad de imagen
print(etiquetas_tigres) #imrpime la lista de las etiquetas
#etiqueta para tigres es 0

etiquetas_pandas = np.repeat(1,15)
print(len(etiquetas_pandas))
print(etiquetas_pandas)
#etiqueta para tigres es 0

class_name=['Tigre','Panda']#mencionar las clases es decir la posicion en que se encuentra
#como se va a llamar las imagenes

labels=np.concatenate([etiquetas_tigres,etiquetas_pandas])#se concatena las etiquetas
print(len(labels)) #imprime la longitud o cantidad de etiquetas
print(labels)# imprime todos
Labels= np.array(labels)# los convierte a un arreglo
print(Labels.shape)#e imprime

plt.figure(figsize=(10,10)) #tama単o de la figura
for i in range(10): #posicion de la imagen en un rango de 10 las primeras
    plt.subplot(5,5,i+1) #crea una figura y uno (o varios) conjunto de ejes, devolviendo una referencia a la figura y a los ejes
    plt.xticks([]) #permiten obtener o establecer las marcas en los ejes(entre valores)
    plt.yticks([])
    plt.grid(False)
    plt.imshow(Imagen[i]) #imprime la imagen
    plt.xlabel(class_name[Labels[i]]) 
plt.show()

# Commented out IPython magic to ensure Python compatibility.
from __future__ import absolute_import, division, print_function, unicode_literals

variable_name = ""
try:
  # %tensorflow_version only exists in Colab.
#   %tensorflow_version 2.x
except Exception:
  pass

from __future__ import absolute_import, division, print_function, unicode_literals


# TensorFlow and tf.keras
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import datasets, layers, models
import tensorflow.keras.optimizers as Optimizer

# Helper libraries
import numpy as np
import matplotlib.pyplot as plt
print(tf.__version__)

#para el entrenamiento del modelo
model = keras.Sequential([ 
    keras.layers.Flatten(input_shape=(150, 150,3)),
    keras.layers.Dense(128, activation='relu'),
    
    keras.layers.Dense(2, activation='softmax'),
    
])
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy']) #mide el porcentaje de casos que el modelo ha acertado
model.fit(Imagen, Labels, epochs=10)#cantidad de iteracciones
trained=model.fit(Imagen, Labels, epochs=10)

img=Imagen[8]  #traer la imagen
print(img.shape)
img =(np.expand_dims(img,0))
print(img.shape)

plt.figure() #mostrar la imagen
plt.imshow(Imagen[8])
plt.colorbar()
plt.grid(False)
plt.show()

predictions_single =model.predict(img) #mostrar la prediccion del modelo en base a la imagen
print(predictions_single) # cual imagen es
print(np.sum(predictions_single)) #predicciones en conjunto
print(np.argmax(predictions_single)) #numero maximo que va a relacionar con la etiqueta
print(class_name[np.argmax(predictions_single)]) #a partir de la prediccion va a ganar el indice y se toma

img=cv2.imread("panda1.jpg")
img_cvt=cv2.cvtColor(img, cv2.COLOR_BGR2RGB )
plt.imshow(img_cvt)
plt.show()

img2=img_cvt
img2=cv2.resize(img2,(img_size,img_size))
print(img2.shape)
img2 = (np.expand_dims(img2,0))
print(img2.shape)


#prediccion del modelo al a単adir una nueva imagen
predictions_single =model.predict(img2) #mostrar la prediccion del modelo en base a la imagen
print(predictions_single) # cual imagen es
print(np.sum(predictions_single)) #predicciones en conjunto
print(np.argmax(predictions_single)) #numero maximo que va a relacionar con la etiqueta
print(class_name[np.argmax(predictions_single)]) #a partir de la prediccion va a ganar el indici y se toma 
#